# Preface

This book introduces a few common tools we can use to improve engineering quality for app development.

By tools, I mean software as well as approaches to software development.

By engineering quality, I mean tools used to maintain quality, with an emphasis on automation.

I call this a "cookbook" because it focuses on a set of verifyable outcomes, like the recipes in a cookbook.

This book biases toward accomodating inexperienced developers, developing applications, cutting scope over quality, holding systems responsible, collaborating, iterating, and having fun.

A broad range of developers can use the tools in this book, but to ensure accessibility, I include the basics for getting started.

I have experience with quality engineering as a Web and Android application developer, and write from this perspective, but I also keep portability in mind.

If the cost of shipping something is high, then I place more emphasis on up-front quality. For example, hacking on something for myself is relatively low cost, and I skip a lot of quality tooling. Developing a physical product for a paying customer, however, is high cost - the product _must_ work - and investment in quality tooling is justified. In a pinch, I recommend erring on the side of quality, i.e., "cut scope, not quality."

I recommend relying on systems rather than individuals. A team can deterministically improve a system, and that system can outlive the individuals on the team. Given it's human to make mistakes, I prefer to work in an environment that minimizes damage.

I recommend against developing code in isolation to reduce stress and increase quality. Software development is often a collaborative activity.

I recommend shipping small changes frequently to reduce risk and facilitate maintenance and damage control. With this in mind, this book is organized such that each page provides incremental value.

I think of software development as a series of fundamental activities, reminiscent of the scientific method: making a change, observing the result, reflecting on the outcome, planning for the next change. Each section in this book is organized in this way.

Building products can be enjoyable, but shipping unpredictable applications via unforgiving systems is a terrible experience. Quality engineering helps me focus on the former.

I hope this book helps more developers ship code with confidence.